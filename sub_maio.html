<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Dashboard • Google Sheets (Light)</title>

  <link rel="preconnect" href="https://fonts.gstatic.com" />
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet" />
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    tailwind.config = {
      theme: {
        fontFamily: { sans: ['Inter', 'ui-sans-serif', 'system-ui'] },
        extend: {
          colors: {
            surface: '#ffffff',
            primary: { // Paleta de Azul da "Tela Home"
              300: '#6abff9',
              400: '#4dabf7',
              500: '#339af0',
              600: '#1b85db',
              700: '#1971c2'
            },
            slate: {
              300: '#dee2e6', 400: '#ced4da', 500: '#adb5bd',
              600: '#6c757d', 700: '#495057', 800: '#343a40', 900: '#212529'
            },
            gray: { 50: '#f8f9fa', 100: '#f1f3f5', 200: '#e9ecef' }
          },
          boxShadow: { glow: '0 0 8px rgba(51, 154, 240, 0.35)' }, // Ajuste leve na sombra para o novo azul
          backdropBlur: { xs: '2px' }
        }
      }
    };
  </script>

  <script src="https://cdn.jsdelivr.net/npm/apexcharts@3.46.0"></script>

  <style>
    @keyframes spin { to { transform: rotate(360deg) } }
    .animate-spin { animation: spin 1s linear infinite }
    html, body { height: 100%; }
    body { background: #f8f9fa; display: flex; flex-direction: column; }
    main { flex-grow: 1; display: flex; flex-direction: column; }
    #table-wrapper { flex-grow: 1; overflow: auto; max-width: 100%; -webkit-overflow-scrolling: touch; }
    #charts-wrapper { flex-grow: 1; overflow-y: auto; }
    #sheetTable { width: 100%; }
    ::-webkit-scrollbar { width: 6px; height: 6px }
    ::-webkit-scrollbar-thumb { background: #adb5bd; border-radius: 3px }
    ::-webkit-scrollbar-track { background: #e9ecef; }
    th select {
      background: #ffffff; border: 1px solid #ced4da; border-radius: 4px;
      font-size: 12px; padding: 6px 8px; width: 100%; margin-top: 4px;
      color: #495057; appearance: none;
      /* Seta SVG com novo azul primário (#339af0) */
      background-image: url('data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%23339af0%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.4c-5%200-9.3%201.8-12.9%205.4A17.6%2017.6%200%200%200%200%2082.2c0%205%201.8%209.3%205.4%2012.9l128%20127.9c3.6%203.6%207.8%205.4%2012.8%205.4s9.2-1.8%2012.8-5.4L287%2095c3.5-3.5%205.4-7.8%205.4-12.8%200-5-1.9-9.2-5.5-12.8z%22%2F%3E%3C%2Fsvg%3E');
      background-repeat: no-repeat; background-position: right 0.5rem center; background-size: 0.65em auto; padding-right: 2rem;
    }
    /* Foco com novo azul primário */
    th select:focus { outline: none; border-color: #86b7fe; box-shadow: 0 0 0 2px rgba(51, 154, 240, 0.25); }
    .tab-btn.active-tab { background: #339af0; color: #fff !important; box-shadow: 0 0 5px rgba(51, 154, 240, .4) }
    .chart-card { transition: background-color 0.3s ease; background-color: var(--tw-color-surface); }
    /* Foco com novo azul primário */
    button:focus-visible, select:focus-visible { outline: 2px solid #339af0; outline-offset: 2px; }
    main.table-full-screen { max-width: none; padding: 0; gap: 0; }
    main.table-full-screen > div:nth-of-type(1) { padding: 0.5rem 0.75rem; flex-shrink: 0; border-bottom: 1px solid #dee2e6; background-color: #f8f9fa; }
    main.table-full-screen > #filters-bar { padding: 0.5rem 0.75rem; flex-shrink: 0; border-bottom: 1px solid #dee2e6; background-color: #f8f9fa; }
    main.table-full-screen > #table-wrapper { border-radius: 0; }
    main.table-full-screen #sheetTable thead th { position: sticky; top: 0; z-index: 10; }
    #sheetTable th, #sheetTable td { padding: 0.5rem 0.5rem; }
    @media (min-width: 640px) { #sheetTable th, #sheetTable td { padding: 0.75rem 1rem; } }
    .refresh-icon { display: inline-block; }
  </style>
</head>
<body class="text-slate-700 min-h-screen flex flex-col antialiased">

  <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
    <symbol id="icon-refresh" viewBox="0 0 20 20" fill="currentColor">
        <path fill-rule="evenodd" d="M4 2a1 1 0 011 1v2.101a7.002 7.002 0 0111.601 2.566 1 1 0 11-1.885.666A5.002 5.002 0 005.999 7H9a1 1 0 110 2H4a1 1 0 01-1-1V4a1 1 0 011-1zm10 10a1 1 0 01-1-1V9.899a7.002 7.002 0 01-11.601-2.566 1 1 0 111.885-.666A5.002 5.002 0 0014.001 13H11a1 1 0 110-2h5a1 1 0 011 1v5a1 1 0 01-1 1z" clip-rule="evenodd" />
    </symbol>
  </svg>

  <header class="w-full backdrop-blur-sm bg-surface/90 border-b border-primary-500/20 sticky top-0 z-40 flex-shrink-0">
    <div class="max-w-screen-2xl mx-auto px-4 sm:px-6 lg:px-8 py-2 flex flex-col">
        <div class="flex justify-between items-center w-full">
            <h1 class="text-base sm:text-lg font-bold text-primary-500 truncate pr-2">Dados e Previsões</h1>
            <button id="manual-refresh"
                    class="inline-flex items-center gap-2 px-3 py-1.5 sm:px-4 sm:py-2 rounded-lg border border-primary-500 bg-primary-500/15 hover:bg-primary-500/25
                           text-primary-600 text-xs sm:text-sm font-medium shadow-glow flex-shrink-0 disabled:opacity-70 disabled:cursor-not-allowed">
                <svg class="refresh-icon w-4 h-4" aria-hidden="true"><use xlink:href="#icon-refresh"></use></svg>
                <span>Atualizar</span>
            </button>
        </div>
        <div class="flex justify-between items-center w-full mt-1">
            <span id="month-total" class="text-primary-500 font-medium text-xs truncate pr-2">Carregando total...</span>
            <span id="last-update" class="text-slate-500 text-xs flex-shrink-0">Carregando...</span>
        </div>
    </div>
  </header>
  <div id="loader" class="fixed inset-0 z-50 flex flex-col items-center justify-center bg-gray-100/80 backdrop-blur-sm">
    <div class="h-10 w-10 border-4 border-primary-500 border-t-transparent rounded-full animate-spin mb-4"></div>
    <p class="text-primary-500 text-base font-medium">Carregando…</p>
  </div>

  <main id="main-content" class="w-full max-w-screen-2xl mx-auto px-4 sm:px-6 lg:px-8 py-4 flex flex-col gap-4 sm:gap-6 flex-grow">
    <div class="flex justify-center space-x-2 sm:space-x-4 flex-shrink-0">
      <button id="tab-table" class="tab-btn px-4 py-2 rounded-lg text-sm font-medium text-slate-600 hover:bg-primary-500/10 hover:text-primary-500 transition-colors duration-200">Tabela</button>
      <button id="tab-charts" class="tab-btn px-4 py-2 rounded-lg text-sm font-medium text-slate-600 hover:bg-primary-500/10 hover:text-primary-500 transition-colors duration-200">Gráficos</button>
    </div>

    <div id="filters-bar" class="flex flex-wrap items-center justify-center gap-2 sm:gap-3 flex-shrink-0">
      <span id="filters-active" class="text-primary-500 text-xs text-center w-full sm:w-auto">Nenhum filtro ativo</span>
      <button id="clear-filters"
              class="px-3 py-1 rounded-md border border-primary-500 bg-primary-500/10 hover:bg-primary-500/20
                     text-primary-500 text-xs font-medium shadow-glow" style="display: none;">
        Limpar Filtros
      </button>
    </div>

    <div id="error-message"
         class="hidden w-full p-3 text-center text-red-700 bg-red-100 border border-red-300 rounded-lg text-sm flex-shrink-0"></div>

    <section id="table-wrapper"
             class="hidden w-full backdrop-blur-xs bg-surface/95 rounded-lg sm:rounded-2xl
                    shadow-lg ring-1 ring-primary-500/10 p-0">
      <table id="sheetTable" class="min-w-full text-sm divide-y divide-gray-200">
        </table>
    </section>

    <section id="charts-wrapper"
             class="hidden w-full grid grid-cols-1 md:grid-cols-2 gap-4 md:gap-6">
      <div class="chart-card bg-surface rounded-lg sm:rounded-2xl shadow-lg ring-1 ring-primary-500/10 p-4 md:col-span-2">
        <h2 class="text-base font-semibold mb-3 text-primary-500">Total por Data de Vencimento</h2>
        <div id="chart-overview"></div>
      </div>
      <div class="chart-card bg-surface rounded-lg sm:rounded-2xl shadow-lg ring-1 ring-primary-500/10 p-4">
        <h2 class="text-base font-semibold mb-3 text-primary-500">Total por Data de Pagamento</h2>
        <div id="chart-payment"></div>
      </div>
      <div class="chart-card bg-surface rounded-lg sm:rounded-2xl shadow-lg ring-1 ring-primary-500/10 p-4">
        <h2 class="text-base font-semibold mb-3 text-primary-500">Total por Mês (Vencimento)</h2>
        <div id="chart-monthly"></div>
      </div>
    </section>
    <br><br><br><br>
  </main>

  <script>
    const sheetId = '1du2FRGYbmY1mQ_mbNN1HuvQc8QhY3Bqq';
    const gid     = '0';
    const baseURL = `https://docs.google.com/spreadsheets/d/${sheetId}/gviz/tq?tqx=out:json&gid=${gid}`;
    const REFRESH_INTERVAL = 60000;
    const CURRENCY_FORMAT = { style: 'currency', currency: 'BRL', maximumFractionDigits: 2 };
    const CHART_COLORS = ['#339af0', '#198754', '#dc3545', '#ffc107', '#6f42c1', '#0dcaf0', '#fd7e14', '#d63384']; // Cor primária atualizada

    let headersFull = [], sheetRows = [];
    let headersDisplay = [];
    let chartOverview, chartPayment, chartMonthly;
    let isLoaded = false, isFetching = false;
    const activeFilters = {};
    let prevOverviewData = null, prevPaymentData = null, prevMonthlyData = null;

    const $loader = document.getElementById('loader');
    const $errorMsg = document.getElementById('error-message');
    const $tableTab = document.getElementById('tab-table');
    const $chartTab = document.getElementById('tab-charts');
    const $tableWrapper = document.getElementById('table-wrapper');
    const $chartWrapper = document.getElementById('charts-wrapper');
    const $sheetTable = document.getElementById('sheetTable');
    const $lastUpdate = document.getElementById('last-update');
    const $monthTotal = document.getElementById('month-total');
    const $filtersActive = document.getElementById('filters-active');
    const $clearFiltersBtn = document.getElementById('clear-filters');
    const $mainContent = document.getElementById('main-content');
    const $manualRefreshBtn = document.getElementById('manual-refresh');
    const $refreshIcon = $manualRefreshBtn?.querySelector('.refresh-icon');
    const $refreshBtnText = $manualRefreshBtn?.querySelector('span');

    if ($manualRefreshBtn) $manualRefreshBtn.onclick = loadData; // Evita erro se o botão não existir
    if ($tableTab) $tableTab.onclick = () => switchTab('table');
    if ($chartTab) $chartTab.onclick = () => switchTab('charts');
    if ($clearFiltersBtn) $clearFiltersBtn.onclick = clearFilters;

    function switchTab(tabId) {
      [$tableTab, $chartTab].forEach(btn => btn?.classList.remove('active-tab'));
      if (tabId === 'table') {
        $tableWrapper?.classList.remove('hidden');
        $chartWrapper?.classList.add('hidden');
        $tableTab?.classList.add('active-tab');
        $mainContent?.classList.add('table-full-screen');
      } else {
        $chartWrapper?.classList.remove('hidden');
        $tableWrapper?.classList.add('hidden');
        $chartTab?.classList.add('active-tab');
        $mainContent?.classList.remove('table-full-screen');
        // Força redraw/reflow dos gráficos ao tornar visível
        setTimeout(() => {
          [chartOverview, chartPayment, chartMonthly].forEach(chart => {
            if (chart && typeof chart.updateOptions === 'function') { // Verifica se updateOptions existe
               // chart.updateOptions({}, false, false, false); // Não essencial, pode causar piscadas
            }
          });
        }, 100);
      }
    }
    async function fetchSheetData() {
      const response = await fetch(`${baseURL}&_=${Date.now()}`); // Cache busting
      if (!response.ok) throw new Error(`Erro HTTP ${response.status} ao buscar dados da planilha.`);
      const text = await response.text();
      // A resposta do Google Sheets é JSONP, precisamos extrair o JSON
      if (!text.startsWith('/*O_o*/\ngoogle.visualization.Query.setResponse(')) {
        console.error("Resposta inválida do Google Sheets (não é JSONP esperado):", text.substring(0, 500));
        throw new Error('Formato de resposta inválido da API do Google Sheets.');
      }
      try {
        return JSON.parse(text.substring(47, text.length - 2));
      } catch (e) {
        console.error("Falha ao analisar JSON da resposta do Google Sheets:", e);
        console.error("Texto recebido (parcial):", text.substring(0, 1000)); // Loga mais do texto para depuração
        throw new Error('Falha ao processar os dados JSON recebidos da planilha.');
      }
    }
    const padZero = num => num.toString().padStart(2, '0');
    const formatDateBR = date => {
        if (!date || isNaN(date.getTime())) return '–';
        // Assegura que estamos usando UTC para evitar problemas de fuso horário com datas da planilha
        return `${padZero(date.getUTCDate())}/${padZero(date.getUTCMonth() + 1)}/${date.getUTCFullYear()}`;
    };
    const formatMonthYear = date => {
        if (!date || isNaN(date.getTime())) return '–';
        const month = date.toLocaleDateString('pt-BR', { month: 'short', timeZone: 'UTC' }).replace('.', ''); // Remove ponto de "abr." etc.
        return `${month.charAt(0).toUpperCase() + month.slice(1)}/${date.getUTCFullYear()}`; // Primeira letra maiúscula
    };

    function parseDateValue(value) {
        if (value instanceof Date) return value; // Já é um objeto Date
        if (value == null) return null; // Null ou undefined

        // Formato "Date(yyyy,MM,dd)" do Google Sheets (MM é 0-indexado)
        if (typeof value === 'string' && value.startsWith('Date(')) {
            try {
                const parts = value.substring(5, value.length - 1).split(',');
                // Ano, Mês (0-11), Dia
                return new Date(Date.UTC(parseInt(parts[0]), parseInt(parts[1]), parseInt(parts[2])));
            } catch (e) {
                return null; // Falha no parse
            }
        }
        // Número serial do Excel/Sheets (dias desde 30/12/1899)
        if (typeof value === 'number' && value > 1 && value < 60000) { // Range razoável para datas Excel
            const excelEpoch = new Date(Date.UTC(1899, 11, 30)); // Data base do Excel (UTC)
            const date = new Date(excelEpoch.getTime() + value * 24 * 60 * 60 * 1000);
            return new Date(Date.UTC(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate())); // Normaliza para UTC
        }

        if (typeof value !== 'string') return null; // Se não for string e não caiu nos casos acima

        let m;
        // Tenta YYYY-MM-DD (comum em APIs)
        m = value.match(/^(\d{4})-(\d{2})-(\d{2})/);
        if (m) return new Date(Date.UTC(+m[1], +m[2] - 1, +m[3]));

        // Tenta DD/MM/YYYY ou DD-MM-YYYY
        m = value.match(/^(\d{1,2})[\/-](\d{1,2})[\/-](\d{2,4})/);
        if (m) {
            let y = +m[3];
            if (y < 100) y += 2000; // Converte ano de 2 dígitos para 4
            return new Date(Date.UTC(y, +m[2] - 1, +m[1]));
        }
        
        // Última tentativa: parse nativo do JS, mas pode ser inconsistente com fusos
        // Melhor evitar se possível, mas como fallback. Normaliza para UTC.
        const p = new Date(value);
        if (p && !isNaN(p.getTime())) {
            return new Date(Date.UTC(p.getFullYear(), p.getMonth(), p.getDate()));
        }
        return null; // Não conseguiu parsear
    }

    const formatCurrency = value => typeof value === 'number' && !isNaN(value) ? value.toLocaleString('pt-BR', CURRENCY_FORMAT) : '–';
    const formatCompact = value => typeof value === 'number' && !isNaN(value) ? value.toLocaleString('pt-BR', { notation: 'compact', maximumFractionDigits: 1 }) : 'N/A';

    async function loadData() {
      if (isFetching) return;
      isFetching = true;
      if ($errorMsg) $errorMsg.classList.add('hidden');
      if ($manualRefreshBtn) $manualRefreshBtn.disabled = true;
      if ($refreshIcon) $refreshIcon.classList.add('animate-spin');
      if ($refreshBtnText) $refreshBtnText.textContent = 'Atualizando...';
      if (!isLoaded && $loader) $loader.classList.remove('hidden');

      try {
        const jsonData = await fetchSheetData();
        if (!jsonData?.table?.cols || !jsonData?.table?.rows) {
          throw new Error("Estrutura de dados recebida da planilha é inválida ou vazia.");
        }

        // Processa cabeçalhos, garantindo que sejam strings
        headersFull = jsonData.table.cols.map(col => (col.label ? String(col.label).trim() : `Coluna ${col.id}`));
        
        const obsIndex = headersFull.findIndex(h => h.toLowerCase().trim() === 'observação');
        headersDisplay = obsIndex === -1 ? [...headersFull] : headersFull.slice(0, obsIndex + 1);

        sheetRows = jsonData.table.rows.map(row => {
          const cells = Array(headersFull.length).fill(null);
          row?.c?.forEach((cell, i) => {
            if (i < headersFull.length) {
              cells[i] = cell?.v ?? null; // Pega o valor 'v' ou null
            }
          });
          return cells;
        });

        if (!isLoaded) {
          buildInitialUI();
          isLoaded = true;
          switchTab('table'); // Ou o tab padrão que desejar
        } else {
          updateUI(); // Apenas atualiza os dados, não recria a UI inteira
        }
        updateGrandTotalHeader();
        if ($lastUpdate) $lastUpdate.textContent = `Atualizado: ${new Date().toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' })}`;

      } catch (error) {
        console.error("Erro detalhado ao carregar dados:", error);
        if ($errorMsg) {
            $errorMsg.textContent = `Erro ao carregar: ${error.message}. Verifique a planilha, permissões e conexão.`;
            $errorMsg.classList.remove('hidden');
        }
        if (!isLoaded) { // Se for o primeiro carregamento e falhou
          if ($tableWrapper) $tableWrapper.classList.add('hidden');
          if ($chartWrapper) $chartWrapper.classList.add('hidden');
        }
      } finally {
        isFetching = false;
        if ($loader) $loader.classList.add('hidden');
        if ($manualRefreshBtn) $manualRefreshBtn.disabled = false;
        if ($refreshIcon) $refreshIcon.classList.remove('animate-spin');
        if ($refreshBtnText) $refreshBtnText.textContent = 'Atualizar';
      }
    }
    loadData(); // Carga inicial dos dados
    setInterval(loadData, REFRESH_INTERVAL); // Auto-refresh

    function buildTable() {
      if (!$sheetTable) return;
      $sheetTable.innerHTML = ''; // Limpa a tabela existente
      const thead = createTableHead();
      const tbody = createTableBody();
      if (thead) $sheetTable.appendChild(thead);
      if (tbody) $sheetTable.appendChild(tbody);
      applyFilters(); // Aplica filtros se houver algum ativo
    }

    function createTableHead() {
      const thead = document.createElement('thead');
      thead.className = 'bg-gray-100 sticky top-0 z-10';
      const tr = document.createElement('tr');
      tr.className = 'divide-x divide-gray-300';

      headersDisplay.forEach((header, index) => {
        const th = document.createElement('th');
        th.className = 'text-left text-xs font-semibold text-slate-600 uppercase bg-gray-100 whitespace-nowrap px-2 sm:px-4 py-2';
        
        const headerText = document.createElement('span');
        headerText.textContent = header || `Coluna ${index + 1}`;
        th.appendChild(headerText);

        // Adiciona select para filtro
        const select = document.createElement('select');
        select.dataset.colIndex = index;
        select.className = 'mt-1 block w-full filter-select'; // Estilo definido em <style>
        select.innerHTML = '<option value="">Todos</option>'; // Opção padrão

        // Popula com valores únicos da coluna
        const uniqueValues = [...new Set(sheetRows.map(row => row[index]))]
            .map(value => formatCellValue(value, header)) // Formata antes de adicionar ao select
            .filter(value => value !== '–' && value != null && String(value).trim() !== '') // Remove vazios ou nulos
            .sort((a, b) => {
                // Tenta ordenação numérica se possível, senão alfabética
                const numA = parseFloat(String(a).replace(/[R$\s.]/g, '').replace(',', '.'));
                const numB = parseFloat(String(b).replace(/[R$\s.]/g, '').replace(',', '.'));
                if (!isNaN(numA) && !isNaN(numB)) return numA - numB;
                return String(a).localeCompare(String(b), 'pt-BR', { sensitivity: 'base' });
            });

        uniqueValues.forEach(value => {
          const opt = document.createElement('option');
          opt.value = value; // O valor da opção será o valor formatado
          opt.textContent = value;
          select.appendChild(opt);
        });
        
        if (activeFilters[index]) { // Se houver filtro ativo para esta coluna
            select.value = activeFilters[index];
        }

        select.onchange = handleFilterChange;
        th.appendChild(select);
        tr.appendChild(th);
      });
      thead.appendChild(tr);
      return thead;
    }

    function handleFilterChange(event) {
        const colIndex = event.target.dataset.colIndex;
        const value = event.target.value;
        if (value) {
            activeFilters[colIndex] = value;
        } else {
            delete activeFilters[colIndex];
        }
        applyFilters();
    }

    function createTableBody() {
        const tbody = document.createElement('tbody');
        tbody.className = 'divide-y divide-gray-200';

        if (sheetRows.length === 0) {
            const tr = document.createElement('tr');
            const td = document.createElement('td');
            td.colSpan = headersDisplay.length || 1;
            td.textContent = 'Nenhum dado encontrado na planilha.';
            td.className = 'px-4 py-8 text-center text-slate-500 text-sm';
            tr.appendChild(td);
            tbody.appendChild(tr);
            return tbody;
        }

        sheetRows.forEach((row, rowIndex) => {
            const tr = document.createElement('tr');
            // Alterna cor de fundo para melhor legibilidade
            tr.className = `${rowIndex % 2 ? 'bg-gray-50' : 'bg-white'} hover:bg-primary-500/10 transition-colors duration-150`;
            tr.dataset.rowIndex = rowIndex; // Para referência, se necessário

            headersDisplay.forEach((header, colIndex) => {
                const td = document.createElement('td');
                td.className = 'whitespace-nowrap px-2 sm:px-4 py-2 align-top text-slate-700';
                const cellValue = row[colIndex];
                td.textContent = formatCellValue(cellValue, header);
                if (td.textContent.length > 50) { // Adiciona title para valores longos
                    td.title = td.textContent;
                }
                tr.appendChild(td);
            });
            tbody.appendChild(tr);
        });
        
        // Linha para feedback de "nenhum resultado" com filtros
        const trNoResults = document.createElement('tr');
        trNoResults.className = 'hidden no-results-row'; // Inicialmente escondida
        const tdNoResults = document.createElement('td');
        tdNoResults.colSpan = headersDisplay.length || 1;
        tdNoResults.textContent = 'Nenhum resultado corresponde aos filtros selecionados.';
        tdNoResults.className = 'px-4 py-8 text-center text-slate-500 text-sm';
        trNoResults.appendChild(tdNoResults);
        tbody.appendChild(trNoResults);

        return tbody;
    }

    function formatCellValue(cellValue, headerLabel) {
        if (cellValue == null || String(cellValue).trim() === '') return '–'; // Trata strings vazias também

        const headerLower = String(headerLabel || '').toLowerCase().trim();

        // Formatação específica para colunas que contêm "NF" (Nota Fiscal) - tratar como texto
        if (headerLower.includes('nf')) return String(cellValue);
        
        // Tentativa de formatar como moeda para colunas com "valor", "total", "preço", etc.
        if (/valor|total|preço|saldo|débito|crédito/i.test(headerLower)) {
            let n = NaN;
            if (typeof cellValue === 'number') {
                n = cellValue;
            } else if (typeof cellValue === 'string') {
                // Tenta limpar e converter string para número (ex: "R$ 1.234,56" -> 1234.56)
                const cleaned = String(cellValue).replace(/[R$\s.]/g, '').replace(',', '.');
                n = parseFloat(cleaned);
            }
            return !isNaN(n) ? formatCurrency(n) : String(cellValue); // Se falhar, retorna como string
        }

        // Tentativa de formatar como data
        const d = parseDateValue(cellValue);
        if (d && !isNaN(d.getTime())) { // Se parseDateValue retornou uma data válida
            if (/data|venc|pag|emissao|nasc/i.test(headerLower)) { // Colunas comuns de data
                return formatDateBR(d);
            }
            // Poderia adicionar lógica para retornar a data mesmo se não for um header comum de data
            // return formatDateBR(d); // Descomente se quiser que qualquer data parseada seja formatada
        }

        // Formatação numérica geral (se não for moeda ou data)
        if (typeof cellValue === 'number') return cellValue.toLocaleString('pt-BR');
        // Tenta converter string que parece número para número formatado
        if (typeof cellValue === 'string' && /^-?\d+([.,]\d+)?$/.test(cellValue.trim())) {
            const numCleaned = cellValue.trim().replace('.', '').replace(',', '.');
            const num = parseFloat(numCleaned);
            if (!isNaN(num)) return num.toLocaleString('pt-BR');
        }
        
        return String(cellValue); // Fallback: retorna como string
    }


    function applyFilters() {
        const tbody = $sheetTable?.querySelector('tbody');
        if (!tbody) return;

        let visibleRowCount = 0;
        const filterKeys = Object.keys(activeFilters);
        const noResultsRow = tbody.querySelector('.no-results-row');

        Array.from(tbody.rows).forEach(tr => {
            if (tr.classList.contains('no-results-row')) return; // Pula a linha de "no results"
            if (tr.parentElement.tagName === 'THEAD') return; // Segurança extra, não deve acontecer

            let show = true;
            if (filterKeys.length > 0) {
                show = filterKeys.every(colIndex => {
                    const filterValue = activeFilters[colIndex];
                    // O conteúdo da célula já está formatado, então a comparação deve ser direta
                    const cellContent = tr.cells[colIndex]?.textContent?.trim() || '';
                    return cellContent === filterValue;
                });
            }
            tr.style.display = show ? '' : 'none';
            if (show) visibleRowCount++;
        });
        
        if(noResultsRow) {
            noResultsRow.style.display = (visibleRowCount === 0 && sheetRows.length > 0 && filterKeys.length > 0) ? '' : 'none';
        }

        updateFilterDisplay();
        updateCharts(); // Atualiza gráficos com base nos filtros
        updateGrandTotalHeader(); // Atualiza o total no header
    }

    function updateFilterDisplay() {
        if (!$filtersActive || !$clearFiltersBtn) return;
        const keys = Object.keys(activeFilters);
        if (keys.length === 0) {
            $filtersActive.textContent = 'Nenhum filtro ativo';
            $clearFiltersBtn.style.display = 'none';
            $filtersActive.classList.add('w-full', 'sm:w-auto');
            $filtersActive.classList.remove('sm:mr-auto');
        } else {
            const parts = keys.map(i => {
                const headerName = headersDisplay[i] || `Coluna ${parseInt(i) + 1}`;
                return `${headerName}: "${activeFilters[i]}"`;
            });
            $filtersActive.textContent = `Filtros Ativos: ${parts.join('; ')}`;
            $clearFiltersBtn.style.display = 'inline-block';
            $filtersActive.classList.remove('w-full');
            $filtersActive.classList.add('sm:w-auto', 'sm:mr-auto');
        }
    }
    function clearFilters() {
        Object.keys(activeFilters).forEach(key => delete activeFilters[key]);
        $sheetTable?.querySelectorAll('thead .filter-select').forEach(sel => sel.value = '');
        applyFilters();
    }
    function hasDataChanged(newData, prevData) {
        if (!prevData && newData) return true; // Se não havia dados antes e agora há
        if (prevData && !newData) return true; // Se havia dados e agora não há
        if (!prevData && !newData) return false; // Se ambos são nulos/vazios

        // Compara labels e totais. Se forem diferentes, os dados mudaram.
        return JSON.stringify(newData.labels) !== JSON.stringify(prevData.labels) ||
               JSON.stringify(newData.totals || newData.series) !== JSON.stringify(prevData.totals || prevData.series); // 'series' para alguns tipos de gráfico
    }


    function aggregateByDate(dateColRegex) {
        const dateIdx = headersFull.findIndex(h => typeof h === 'string' && h && dateColRegex.test(h.toLowerCase()));
        const valIdx = headersFull.findIndex(h => typeof h === 'string' && h && /valor|total/i.test(h.toLowerCase()) && !/nf/i.test(h.toLowerCase()));

        if (dateIdx === -1 || valIdx === -1) {
            console.warn(`Colunas para agregação por data (${dateColRegex.source}) não encontradas. DateIdx: ${dateIdx}, ValIdx: ${valIdx}`);
            return { labels: [], totals: [] };
        }
        const map = new Map();
        getFilteredRows().forEach(row => {
            const dateValue = row[dateIdx];
            const rawValue = row[valIdx];
            const d = parseDateValue(dateValue);
            if (!d || isNaN(d.getTime())) return;

            const key = d.toISOString().split('T')[0]; // YYYY-MM-DD como chave para agrupar
            
            let v = NaN;
            if (rawValue == null) return;
            if (typeof rawValue === 'number') { v = rawValue; }
            else if (typeof rawValue === 'string') {
                const cleaned = String(rawValue).replace(/[R$\s.]/g, '').replace(',', '.');
                v = parseFloat(cleaned);
            }
            if (!isNaN(v)) {
                map.set(key, (map.get(key) || 0) + v);
            }
        });
        const entries = [...map.entries()].sort((a, b) => a[0].localeCompare(b[0])); // Ordena por data
        return {
            labels: entries.map(([key]) => formatDateBR(new Date(key + 'T00:00:00Z'))), // Adiciona T00:00:00Z para tratar como UTC ao criar nova Date
            totals: entries.map(([_, value]) => parseFloat(value.toFixed(2)))
        };
    }

    function aggregateByMonth(dateColRegex) {
        const dateIdx = headersFull.findIndex(h => typeof h === 'string' && h && dateColRegex.test(h.toLowerCase()));
        const valIdx = headersFull.findIndex(h => typeof h === 'string' && h && /valor|total/i.test(h.toLowerCase()) && !/nf/i.test(h.toLowerCase()));

        if (dateIdx === -1 || valIdx === -1) {
            console.warn(`Colunas para agregação por mês (${dateColRegex.source}) não encontradas. DateIdx: ${dateIdx}, ValIdx: ${valIdx}`);
            return { labels: [], totals: [] };
        }
        const map = new Map();
        getFilteredRows().forEach(row => {
            const dateValue = row[dateIdx];
            const rawValue = row[valIdx];
            const d = parseDateValue(dateValue);
            if (!d || isNaN(d.getTime())) return;

            // Chave como 'YYYY-MM' para ordenação correta, depois formata para exibição
            const key = `${d.getUTCFullYear()}-${padZero(d.getUTCMonth() + 1)}`; // Mês é 0-indexado, +1 para 1-12
            
            let v = NaN;
            if (rawValue == null) return;
            if (typeof rawValue === 'number') { v = rawValue; }
            else if (typeof rawValue === 'string') {
                const cleaned = String(rawValue).replace(/[R$\s.]/g, '').replace(',', '.');
                v = parseFloat(cleaned);
            }
            if (!isNaN(v)) {
                map.set(key, (map.get(key) || 0) + v);
            }
        });
        const entries = [...map.entries()].sort((a, b) => a[0].localeCompare(b[0]));
        return {
            labels: entries.map(([key]) => {
                const [y, m] = key.split('-');
                return formatMonthYear(new Date(Date.UTC(+y, +m - 1, 1))); // Mês -1 para Date constructor
            }),
            totals: entries.map(([_, value]) => parseFloat(value.toFixed(2)))
        };
    }
    
    function getFilteredRows() {
        const filterKeys = Object.keys(activeFilters);
        if (filterKeys.length === 0) {
            return sheetRows; // Retorna todas as linhas se não houver filtros
        }
        // Retorna linhas que correspondem a TODOS os filtros ativos
        return sheetRows.filter(row => {
            return filterKeys.every(colIndexStr => {
                const colIndex = parseInt(colIndexStr, 10); // Chaves de activeFilters são strings
                const filterValue = activeFilters[colIndex];
                // Formata o valor da célula da mesma forma que foi formatado para o select de filtro
                const cellFormattedValue = formatCellValue(row[colIndex], headersDisplay[colIndex]);
                return String(cellFormattedValue).trim() === String(filterValue).trim();
            });
        });
    }
    const baseChartOptions = {
        chart: {
            fontFamily: 'Inter, sans-serif',
            foreColor: '#495057', // slate-700
            toolbar: { show: false }, // Simplificado, pode reativar se necessário
            zoom: { enabled: false },
            animations: { enabled: true, easing: 'easeinout', speed: 600 },
            background: 'transparent'
        },
        tooltip: {
            theme: 'light',
            style: { fontSize: '11px', fontFamily: 'Inter, sans-serif' },
            x: { show: false }, // Geralmente não necessário para donuts, útil para barras/linhas
            y: { formatter: formatCurrency, title: { formatter: (seriesName) => seriesName ? seriesName + ':' : '' } },
            marker: { show: true },
        },
        dataLabels: { enabled: false }, // Geralmente desabilitado para não poluir, pode ser ativado por gráfico
        grid: {
            borderColor: '#e9ecef', // slate-200
            strokeDashArray: 4,
            padding: { left: 5, right: 15, top: 0, bottom: 0 }
        },
        legend: {
            show: true, // Mostrar por padrão
            fontSize: '11px',
            fontFamily: 'Inter, sans-serif',
            offsetY: 5,
            itemMargin: { horizontal: 5, vertical: 2 },
            labels: { colors: '#495057' } // slate-700
        },
        markers: { size: 0, strokeWidth: 0, hover: { size: 5 } }, // Para gráficos de linha/área
        noData: {
            text: 'Sem dados para exibir',
            align: 'center', verticalAlign: 'middle',
            style: { color: '#6c757d', fontSize: '12px', fontFamily: 'Inter, sans-serif' }
        }
    };
    const areaBaseOptions = {
        ...baseChartOptions,
        chart: {
            ...baseChartOptions.chart,
            type: 'area',
            height: 280, // Altura ajustada
            toolbar: { show: true, tools: { download: true, selection: true, zoom: true, zoomin: true, zoomout: true, pan: true, reset: true }, autoSelected: 'zoom' },
            zoom: { enabled: true }
        },
        xaxis: {
            categories: [], type: 'category',
            tickAmount: 6, // Ajusta o número de ticks
            labels: { show: true, rotate: -45, rotateAlways: false, hideOverlappingLabels: true, trim: true, style: { fontSize: '10px', colors: ['#6c757d'] } },
            tooltip: { enabled: false },
            title: { text: 'Data', style: { color: '#6c757d', fontSize: '10px', fontWeight: 'normal' } },
            axisBorder: { show: true, color: '#ced4da' },
            axisTicks: { show: true, color: '#ced4da' },
        },
        yaxis: {
            labels: { show: true, style: { fontSize: '10px', colors: ['#6c757d'] }, formatter: formatCompact },
            title: { text: 'Valor (R$)', style: { color: '#6c757d', fontSize: '10px', fontWeight: 'normal' } },
            axisBorder: { show: false },
            axisTicks: { show: false },
        },
        tooltip: { // Tooltip personalizado para área
            ...baseChartOptions.tooltip,
            shared: false, // Mostrar tooltip individual por ponto
            intersect: true,
            x: { formatter: function(val, { dataPointIndex, w }) { return w.globals.categoryLabels?.[dataPointIndex] ?? ''; } },
            y: { formatter: formatCurrency, title: { formatter: (seriesName) => seriesName ? seriesName + ':' : '' } }
        },
        markers: { size: 3, strokeWidth: 1, hover: { size: 6 } },
        stroke: { curve: 'smooth', width: 2.5 }, // Linha mais grossa
        fill: { type: 'gradient', gradient: { shadeIntensity: 0.4, opacityFrom: 0.7, opacityTo: 0.2, stops: [0, 95, 100] } }
    };

    const overviewOptions = { ...areaBaseOptions, colors: [CHART_COLORS[0]], };
    const paymentOptions  = { ...areaBaseOptions, colors: [CHART_COLORS[1]], chart: {...areaBaseOptions.chart, height: 280} }; // Altura pode ser diferente

    const monthlyOptions = { // Para gráfico de Donut
        ...baseChartOptions,
        chart: { ...baseChartOptions.chart, type: 'donut', height: 320, }, // Altura ajustada
        labels: [], // Será preenchido com dados
        colors: CHART_COLORS,
        legend: { // Legenda personalizada para Donut
            ...baseChartOptions.legend,
            show: true, position: 'bottom', horizontalAlign: 'center', offsetY: 0,
            formatter: function(seriesName, opts) {
                const value = opts.w.globals.series[opts.seriesIndex];
                return `${seriesName}: ${formatCurrency(value)}`;
            }
        },
        tooltip: { // Tooltip para Donut
            ...baseChartOptions.tooltip,
            y: {
                formatter: function(value, { seriesIndex, dataPointIndex, w }) {
                    const total = w.globals.seriesTotals.reduce((a, b) => a + b, 0);
                    const percentage = total === 0 ? 0 : (value / total * 100);
                    return `${formatCurrency(value)} (${percentage.toFixed(1)}%)`;
                },
                title: { formatter: (seriesName) => seriesName } // Usa o label da fatia como título
            }
        },
        plotOptions: {
            pie: {
                donut: {
                    size: '65%', // Tamanho do buraco do donut
                    labels: {
                        show: true,
                        total: {
                            show: true, showAlways: true,
                            label: 'Total (Filtro)', fontSize: '13px', fontWeight: 600, color: '#495057',
                            formatter: (w) => {
                                const total = w.globals.seriesTotals.reduce((a, b) => a + b, 0);
                                return formatCurrency(total);
                            }
                        },
                        value: { show: true, fontSize: '16px', fontWeight: 500, color: '#495057', formatter: (val) => formatCurrency(parseFloat(val)) }
                    }
                }
            }
        },
        responsive: [{ // Ajustes responsivos para o Donut
            breakpoint: 480,
            options: {
                chart: { height: 280 }, // Menor altura em telas pequenas
                legend: { fontSize: '10px', itemMargin: { horizontal: 4, vertical: 1 }, },
                plotOptions: { pie: { donut: { size: '70%', labels: { total: { fontSize: '12px' }, value: { fontSize: '14px' } } } } }
            }
        }]
    };
    function destroyChart(chartInstance) {
        if (chartInstance && typeof chartInstance.destroy === 'function' && chartInstance.paper) { // Adiciona check por .paper
            try {
                chartInstance.destroy();
            } catch (e) {
                console.warn("Erro menor ao destruir gráfico (pode já ter sido removido):", e);
            }
        }
        return null;
    }
    function buildCharts() {
        // Limpa instâncias antigas se existirem
        chartOverview = destroyChart(chartOverview);
        chartPayment  = destroyChart(chartPayment);
        chartMonthly  = destroyChart(chartMonthly);

        // Pega os dados agregados (baseado nos filtros atuais via getFilteredRows)
        const overviewData = aggregateByDate(/venc/i); // Regex para encontrar coluna de vencimento
        const paymentData  = aggregateByDate(/pag/i);  // Regex para coluna de pagamento
        const monthlyData  = aggregateByMonth(/venc/i); // Regex para coluna de vencimento para agregação mensal

        // Renderiza os gráficos
        renderOverviewChart(false, overviewData);
        renderPaymentChart(false, paymentData);
        renderMonthlyChart(false, monthlyData);
    }

    function updateCharts() {
        const overviewData = aggregateByDate(/venc/i);
        const paymentData  = aggregateByDate(/pag/i);
        const monthlyData  = aggregateByMonth(/venc/i);

        renderOverviewChart(true, overviewData);
        renderPaymentChart(true, paymentData);
        renderMonthlyChart(true, monthlyData);
    }

    function renderOverviewChart(isUpdate = false, data) {
        const chartEl = document.querySelector('#chart-overview');
        if (!chartEl) return;
        if (isUpdate && !hasDataChanged(data, prevOverviewData) && chartOverview) return; // Sem mudanças, não renderiza

        const opts = {
            series: [{ name: 'Total Venc.', data: data.totals }],
            xaxis: { ...overviewOptions.xaxis, categories: data.labels }
        };
        if (isUpdate && chartOverview && chartOverview.paper) { chartOverview.updateOptions(opts, true, true); }
        else {
            chartOverview = destroyChart(chartOverview); // Garante limpeza
            chartOverview = new ApexCharts(chartEl, { ...overviewOptions, ...opts });
            chartOverview.render().catch(e => console.error("Erro ao renderizar chart-overview:", e));
        }
        prevOverviewData = data;
    }

    function renderPaymentChart(isUpdate = false, data) {
        const chartEl = document.querySelector('#chart-payment');
        if (!chartEl) return;
        if (isUpdate && !hasDataChanged(data, prevPaymentData) && chartPayment) return;

        const opts = {
            series: [{ name: 'Total Pago', data: data.totals }],
            xaxis: { ...paymentOptions.xaxis, categories: data.labels }
        };
        if (isUpdate && chartPayment && chartPayment.paper) { chartPayment.updateOptions(opts, true, true); }
        else {
            chartPayment = destroyChart(chartPayment);
            chartPayment = new ApexCharts(chartEl, { ...paymentOptions, ...opts });
            chartPayment.render().catch(e => console.error("Erro ao renderizar chart-payment:", e));
        }
        prevPaymentData = data;
    }

    function renderMonthlyChart(isUpdate = false, data) {
        const chartEl = document.querySelector('#chart-monthly');
        if (!chartEl) return;
        if (isUpdate && !hasDataChanged(data, prevMonthlyData) && chartMonthly) return;

        const opts = {
            series: data.totals, // Para donut, series é um array de valores
            labels: data.labels, // Labels para cada fatia
        };
        if (isUpdate && chartMonthly && chartMonthly.paper) { chartMonthly.updateOptions(opts, true, true); }
        else {
            chartMonthly = destroyChart(chartMonthly);
            chartMonthly = new ApexCharts(chartEl, { ...monthlyOptions, ...opts });
            chartMonthly.render().catch(e => console.error("Erro ao renderizar chart-monthly:", e));
        }
        prevMonthlyData = data;
    }

    function updateGrandTotalHeader() {
        if (!$monthTotal) return;
        const { totals } = aggregateByMonth(/venc/i); // Baseado na coluna de vencimento
        const grandTotal = totals.reduce((sum, monthTotal) => sum + monthTotal, 0);
        const filterSuffix = Object.keys(activeFilters).length > 0 ? ' (Filtrado)' : '';
        $monthTotal.textContent = `Total Mês (Venc.)${filterSuffix}: ${formatCurrency(grandTotal)}`;
    }
    function buildInitialUI() {
      buildTable();
      buildCharts();
    }
    function updateUI() { // Chamado após um refresh de dados, não no primeiro load
      buildTable(); // Recria a tabela com novos dados (inclusive filtros)
      // buildCharts(); // Recria os gráficos. Alternativamente, apenas updateCharts() se a estrutura não muda.
      // Para garantir que os gráficos reflitam os dados mais recentes, incluindo filtros,
      // é melhor recriar ou garantir que `updateCharts` use os dados filtrados.
      // As funções aggregateBy* já usam getFilteredRows(), então updateCharts() deve ser suficiente.
      updateCharts();
    }
  </script>
</body>
</html>
