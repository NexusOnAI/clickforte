<!DOCTYPE html>
<html lang="pt-BR" class="dark">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Dashboard • Google Sheets</title>

  <link rel="preconnect" href="https://fonts.gstatic.com" />
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet" />
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    tailwind.config = {
      darkMode: 'class',
      theme: {
        fontFamily: { sans: ['Inter', 'ui-sans-serif', 'system-ui'] },
        extend: {
          colors: {
            surface: '#1f2937',
            primary: { 500: '#60a5fa' },
            slate: {
              300: '#cbd5e1', 400: '#94a3b8', 500: '#64748b',
              600: '#475569', 700: '#334155'
            }
          },
          boxShadow: { glow: '0 0 8px rgba(96, 165, 250, 0.35)' },
          backdropBlur: { xs: '2px' }
        }
      }
    };
  </script>

  <script src="https://cdn.jsdelivr.net/npm/apexcharts@3.46.0"></script>

  <style>
    @keyframes spin { to { transform: rotate(360deg) } }
    .animate-spin { animation: spin 1s linear infinite }
    body { background: #111827; }
    #table-wrapper,
    #charts-wrapper { flex-grow: 1; overflow-y: auto }
    #sheetTable { width: 100%; }
    ::-webkit-scrollbar { width: 8px; height: 8px }
    ::-webkit-scrollbar-thumb { background: #4b5563; border-radius: 4px }

    th select {
      background: #1f2937; border: 1px solid #475569; border-radius: 4px;
      font-size: 11px; padding: 3px 5px; width: 100%; margin-top: 4px;
      color: #cbd5e1; appearance: none;
      background-image: url('data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%2360a5fa%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.4c-5%200-9.3%201.8-12.9%205.4A17.6%2017.6%200%200%200%200%2082.2c0%205%201.8%209.3%205.4%2012.9l128%20127.9c3.6%203.6%207.8%205.4%2012.8%205.4s9.2-1.8%2012.8-5.4L287%2095c3.5-3.5%205.4-7.8%205.4-12.8%200-5-1.9-9.2-5.5-12.8z%22%2F%3E%3C%2Fsvg%3E');
      background-repeat: no-repeat; background-position: right 0.5rem center;
      background-size: 0.65em auto; padding-right: 2rem;
    }
    th select:focus {
       outline: none; border-color: #60a5fa;
       box-shadow: 0 0 0 2px rgba(96, 165, 250, 0.3);
    }
    .tab-btn.active-tab {
      background: #60a5fa; color: #fff !important;
      box-shadow: 0 0 5px rgba(96, 165, 250, .55);
    }
    .chart-card, .info-card {
      transition: background-color 0.3s ease; background: #1f2937;
      border-radius: 1rem;
      box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
      padding: 1.5rem; border: 1px solid rgba(96, 165, 250, 0.2);
    }
    button:focus-visible, select:focus-visible {
      outline: 2px solid #60a5fa; outline-offset: 2px;
    }
  </style>
</head>
<body class="text-slate-300 min-h-screen flex flex-col antialiased">

  <header class="w-full backdrop-blur-sm bg-surface/80 border-b border-primary-500/40 sticky top-0 z-40">
    <div class="max-w-screen-2xl mx-auto px-4 sm:px-6 lg:px-8 h-16 flex flex-wrap items-center justify-between gap-x-4 gap-y-2">
      <h1 class="text-lg sm:text-xl lg:text-2xl font-extrabold text-primary-500 order-1 sm:order-none">Dashboard • Google Sheets</h1>
      <div class="flex items-center gap-3 sm:gap-4 order-3 sm:order-none w-full sm:w-auto justify-center sm:justify-end">
          <span id="month-total" class="text-primary-500 font-semibold text-xs sm:text-sm text-center"></span>
          <span id="last-update" class="text-slate-400 text-xs sm:text-sm text-center"></span>
      </div>
      <button id="manual-refresh"
              class="px-3 py-1.5 sm:px-4 sm:py-2 rounded-md border border-primary-500 bg-primary-500/10 hover:bg-primary-500/20
                     text-primary-300 text-xs sm:text-sm font-medium shadow-glow order-2 sm:order-none ml-auto sm:ml-0">
        Atualizar
      </button>
    </div>
  </header>

  <div id="loader" class="fixed inset-0 z-50 flex flex-col items-center justify-center bg-gray-900/80 backdrop-blur-md">
    <div class="h-12 w-12 border-[6px] border-primary-500 border-t-transparent rounded-full animate-spin mb-6"></div>
    <p class="text-primary-300 text-lg font-medium">Carregando…</p>
  </div>

  <main class="w-full max-w-screen-2xl mx-auto px-4 sm:px-6 lg:px-8 py-6 flex flex-col gap-6 flex-grow">
    <div class="flex justify-center space-x-4">
      <button id="tab-table" class="tab-btn px-5 py-2 rounded-lg font-medium text-slate-300 hover:bg-primary-500/10 transition-colors duration-200">Tabela</button>
      <button id="tab-charts" class="tab-btn px-5 py-2 rounded-lg font-medium text-slate-300 hover:bg-primary-500/10 transition-colors duration-200">Gráficos</button>
    </div>

    <div id="filters-bar" class="flex flex-wrap items-center justify-center gap-3">
      <span id="filters-active" class="text-primary-500 text-sm text-center">Nenhum filtro ativo</span>
      <button id="clear-filters"
              class="px-3 py-1 rounded-md border border-primary-500 bg-primary-500/10 hover:bg-primary-500/20
                     text-primary-300 text-xs font-medium shadow-glow" style="display: none;">
        Limpar Filtros
      </button>
    </div>

    <div id="error-message"
         class="hidden w-full p-4 text-center text-red-300 bg-red-800/40 border border-red-600 rounded-lg"></div>

    <section id="table-wrapper"
             class="hidden w-full overflow-x-auto backdrop-blur-xs bg-surface/70 rounded-2xl
                    shadow-lg ring-1 ring-slate-700 p-4 sm:p-0">
      <table id="sheetTable" class="min-w-full text-sm divide-y divide-slate-700"></table>
    </section>

    <section id="charts-wrapper"
             class="hidden w-full grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6 md:gap-8">

      <div class="chart-card lg:col-span-2">
        <h2 class="text-base sm:text-lg font-semibold mb-4 text-primary-500">Total por Data de Vencimento</h2>
        <div id="chart-overview"></div>
      </div>

      <div class="chart-card">
        <h2 class="text-base sm:text-lg font-semibold mb-4 text-primary-500">Total por Data de Pagamento</h2>
        <div id="chart-payment"></div>
      </div>

      <div class="chart-card">
        <h2 class="text-base sm:text-lg font-semibold mb-4 text-primary-500">Total por Mês (Vencimento)</h2>
        <div id="chart-monthly"></div>
      </div>

      <div id="card-tomorrow" class="info-card flex flex-col justify-center items-center text-center">
         <h2 class="text-base sm:text-lg font-semibold mb-2 text-primary-500">Vencendo Amanhã</h2>
         <p id="tomorrow-total-value" class="text-2xl font-bold text-slate-100">R$ 0,00</p>
         <p id="tomorrow-date" class="text-xs text-slate-400 mt-1"></p>
       </div>

    </section>
  </main>

  <script>
    const sheetId = '1du2FRGYbmY1mQ_mbNN1HuvQc8QhY3Bqq';
    const gid     = '0';
    const baseURL = `https://docs.google.com/spreadsheets/d/${sheetId}/gviz/tq?tqx=out:json&gid=${gid}`;
    const REFRESH_INTERVAL = 600000; // <-- Alterado para 600.000 ms = 10 minutos
    const CURRENCY_FORMAT = { style: 'currency', currency: 'BRL', maximumFractionDigits: 2 };
    const CHART_COLORS = ['#60a5fa', '#34d399', '#fbbf24', '#f87171', '#a78bfa', '#2dd4bf'];

    let headersFull = [], sheetRows = [];
    let headersDisplay = [];
    let chartOverview, chartPayment, chartMonthly;
    let isLoaded = false, isFetching = false;
    const activeFilters = {};

    let prevOverviewData = null, prevPaymentData = null, prevMonthlyData = null;
    let prevTomorrowTotal = null;

    const $loader = document.getElementById('loader');
    const $errorMsg = document.getElementById('error-message');
    const $tableTab = document.getElementById('tab-table');
    const $chartTab = document.getElementById('tab-charts');
    const $tableWrapper = document.getElementById('table-wrapper');
    const $chartWrapper = document.getElementById('charts-wrapper');
    const $sheetTable = document.getElementById('sheetTable');
    const $lastUpdate = document.getElementById('last-update');
    const $monthTotal = document.getElementById('month-total');
    const $filtersActive = document.getElementById('filters-active');
    const $clearFiltersBtn = document.getElementById('clear-filters');
    const $tomorrowTotalValue = document.getElementById('tomorrow-total-value');
    const $tomorrowDate = document.getElementById('tomorrow-date');

    document.getElementById('manual-refresh').onclick = loadData;
    $tableTab.onclick = () => switchTab('table');
    $chartTab.onclick = () => switchTab('charts');
    $clearFiltersBtn.onclick = clearFilters;

    function switchTab(tabId) {
      [$tableTab, $chartTab].forEach(btn => btn.classList.remove('active-tab'));
      if (tabId === 'table') {
        $tableWrapper.classList.remove('hidden');
        $chartWrapper.classList.add('hidden');
        $tableTab.classList.add('active-tab');
      } else {
        $chartWrapper.classList.remove('hidden');
        $tableWrapper.classList.add('hidden');
        $chartTab.classList.add('active-tab');
        setTimeout(() => [chartOverview, chartPayment, chartMonthly]
          .forEach(chart => chart?.updateOptions({}, false, false, false)), 50);
      }
    }

    async function fetchSheetData() {
      const response = await fetch(`${baseURL}&_=${Date.now()}`);
      if (!response.ok) throw new Error(`HTTP error ${response.status}`);
      const text = await response.text();
      if (!text.startsWith('/*O_o*/\ngoogle.visualization.Query.setResponse(')) {
        console.error("Invalid Response Text:", text);
        throw new Error('Formato de resposta inválido da API do Google Sheets.');
      }
      try {
          return JSON.parse(text.substring(47, text.length - 2));
      } catch(e) {
          console.error("Error parsing JSON:", e);
          console.error("Substring attempted:", text.substring(47, text.length - 2));
          throw new Error('Erro ao processar JSON da resposta do Google Sheets.');
      }
    }

    const padZero = num => num.toString().padStart(2, '0');

    const formatDateBR = date => {
        if (!date || isNaN(date.getTime())) return '–';
        return `${padZero(date.getUTCDate())}/${padZero(date.getUTCMonth() + 1)}/${date.getUTCFullYear()}`;
    };

    const formatMonthYear = date => {
        if (!date || isNaN(date.getTime())) return '–';
        const month = date.toLocaleDateString('pt-BR', { month: 'short', timeZone: 'UTC' });
        const year = date.getUTCFullYear();
        const formattedMonth = month.charAt(0).toUpperCase() + month.slice(1).replace('.', '');
        return `${formattedMonth}/${year}`;
    };

    function parseDateValue(value) {
        if (value instanceof Date) return value;
        if (value == null) return null;

        if (typeof value === 'number' && value > 1 && value < 60000) {
            const utcDays = Math.floor(value - 25569);
            const date = new Date(0);
            date.setUTCDate(date.getUTCDate() + utcDays);
            return date;
        }

        if (typeof value !== 'string') return null;

        let match;
        match = value.match(/^Date\((\d{4}),\s*(\d{1,2}),\s*(\d{1,2})\)/);
        if (match) {
            return new Date(Date.UTC(+match[1], +match[2], +match[3]));
        }

        match = value.match(/^(\d{4})-(\d{2})-(\d{2})/);
        if (match) {
            return new Date(Date.UTC(+match[1], +match[2] - 1, +match[3]));
        }

        match = value.match(/^(\d{1,2})[\/-](\d{1,2})[\/-](\d{2,4})/);
        if (match) {
            let year = +match[3];
            if (year < 100) year += 2000;
            return new Date(Date.UTC(year, +match[2] - 1, +match[1]));
        }

        const standardizedDateString = value.replace(/[\/-]/g, '-');
        const parsed = new Date(standardizedDateString);
         if (!isNaN(parsed.getTime())) {
             return new Date(Date.UTC(parsed.getFullYear(), parsed.getMonth(), parsed.getDate()));
         }

        console.warn(`Could not parse date value: ${value}`);
        return null;
    }

    const formatCurrency = value => typeof value === 'number' ? value.toLocaleString('pt-BR', CURRENCY_FORMAT) : 'R$ 0,00';

    const formatCompact = value => typeof value === 'number' ? value.toLocaleString('pt-BR', { notation: 'compact', maximumFractionDigits: 1 }): '0';

    const formatTooltip = value => typeof value === 'number' ? formatCurrency(value) : 'N/A';

    async function loadData() {
      if (isFetching) return;
      isFetching = true;
      $errorMsg.classList.add('hidden');
      if (!isLoaded) $loader.classList.remove('hidden');

      try {
        const jsonData = await fetchSheetData();

        headersFull = jsonData.table.cols.map(col => col.label || `Col${col.id}`);
        sheetRows = jsonData.table.rows.map(row => row.c?.map(cell => cell?.v ?? null) ?? []);

        const obsIndex = headersFull.findIndex(header => header.toLowerCase().trim() === 'observação');
        headersDisplay = obsIndex === -1 ? [...headersFull] : headersFull.slice(0, obsIndex + 1);

        if (!isLoaded) {
          buildInitialUI();
          isLoaded = true;
          switchTab('table');
        } else {
          updateUI();
        }

        updateGrandTotalHeader();
        $lastUpdate.textContent = `Atualizado: ${new Date().toLocaleTimeString('pt-BR')}`;

      } catch (error) {
        console.error("Erro ao carregar dados:", error);
        $errorMsg.textContent = `Erro ao carregar dados: ${error.message}. Verifique ID/GID da Planilha e permissões.`;
        $errorMsg.classList.remove('hidden');
      } finally {
        isFetching = false;
        $loader.classList.add('hidden');
      }
    }

    function buildTable() {
      $sheetTable.innerHTML = '';
      $sheetTable.appendChild(createTableHead());
      $sheetTable.appendChild(createTableBody());
      updateFilterDisplay();
    }

    function isNumericOrDateColumn(headerLabel) {
        const headerLower = headerLabel.toLowerCase().trim();
        return /valor|total|preço|custo|data|venc|pagto|emiss[aã]o/i.test(headerLower);
    }

    function createTableHead() {
      const thead = document.createElement('thead');
      thead.className = 'bg-surface/90';
      const tr = document.createElement('tr');
      tr.className = 'divide-x divide-slate-700';

      headersDisplay.forEach((header, index) => {
        const th = document.createElement('th');
        const isNumericDate = isNumericOrDateColumn(header);
        th.className = `px-4 py-2.5 ${isNumericDate ? 'text-right' : 'text-left'} text-xs font-semibold text-slate-300 uppercase sticky top-0 bg-surface/95 whitespace-nowrap`;
        const headerText = document.createElement('span');
        headerText.textContent = header;
        th.appendChild(headerText);

        const select = document.createElement('select');
        select.dataset.colIndex = index;
        select.onchange = handleFilterChange;
        select.innerHTML = '<option value="">Todos</option>';

        const uniqueValues = [...new Set(sheetRows.map(row => formatCellValue(row[index], header)))]
          .filter(value => value !== '–' && value !== null && value !== '')
          .sort((a, b) => {
            const numA = parseFloat(String(a).replace(/[R$\s.]/g, '').replace(',', '.'));
            const numB = parseFloat(String(b).replace(/[R$\s.]/g, '').replace(',', '.'));
            if (!isNaN(numA) && !isNaN(numB)) return numA - numB;

            const dateA = parseDateValue(a);
            const dateB = parseDateValue(b);
             if (dateA && dateB && !isNaN(dateA.getTime()) && !isNaN(dateB.getTime())) {
                 return dateA.getTime() - dateB.getTime();
             }
            return String(a).localeCompare(String(b), 'pt-BR', { sensitivity: 'base' });
           });

        uniqueValues.forEach(value => {
          const option = document.createElement('option');
          option.value = value;
          option.textContent = value;
          select.appendChild(option);
        });

        if (activeFilters[index]) {
          select.value = activeFilters[index];
        }

        th.appendChild(select);
        tr.appendChild(th);
      });

      thead.appendChild(tr);
      return thead;
    }

    function handleFilterChange(event) {
        const colIndex = event.target.dataset.colIndex;
        const value = event.target.value;
        if (value) {
            activeFilters[colIndex] = value;
        } else {
            delete activeFilters[colIndex];
        }
        applyFilters();
    }

    function createTableBody() {
      const tbody = document.createElement('tbody');
      tbody.className = 'divide-y divide-slate-700';

      sheetRows.forEach((row, rowIndex) => {
        const tr = document.createElement('tr');
        tr.className = `${rowIndex % 2 ? 'bg-surface/70' : 'bg-surface/60'} hover:bg-slate-600/80 transition-colors duration-150`;

        headersDisplay.forEach((header, colIndex) => {
          const td = document.createElement('td');
          const isNumericDate = isNumericOrDateColumn(header);
          td.className = `px-4 py-2.5 ${isNumericDate ? 'text-right' : 'text-left'} whitespace-nowrap`;
          td.textContent = formatCellValue(row[colIndex], header);
          tr.appendChild(td);
        });
        tbody.appendChild(tr);
      });
      return tbody;
    }

    function formatCellValue(cellValue, headerLabel) {
        const headerLower = headerLabel.toLowerCase().trim();

        if (headerLower === 'nf' || headerLower === 'observação') {
             return cellValue == null || String(cellValue).trim() === '' ? '–' : cellValue;
        }

        if (/valor|total|preço|custo/i.test(headerLower)) {
            let numericValue = NaN;
            if (typeof cellValue === 'number') {
                numericValue = cellValue;
            } else if (typeof cellValue === 'string') {
                const cleanedString = String(cellValue).replace(/[R$\s.]/g, '').replace(',', '.');
                numericValue = parseFloat(cleanedString);
            }
            return isNaN(numericValue) ? (cellValue == null || String(cellValue).trim() === '' ? '–' : cellValue) : formatCurrency(numericValue);
        }

        const mightBeDate = /data|venc|pagto|emiss[aã]o/i.test(headerLower);
        if(mightBeDate) {
            const dateValue = parseDateValue(cellValue);
            if (dateValue && !isNaN(dateValue.getTime())) {
                return formatDateBR(dateValue);
            }
        }

        if (typeof cellValue === 'number') {
            return cellValue.toLocaleString('pt-BR');
        }
        if (typeof cellValue === 'string' && /^\d+(\.\d+)?$/.test(cellValue)) {
             const num = parseFloat(cellValue);
             if (!isNaN(num)) return num.toLocaleString('pt-BR');
        }

        return cellValue == null || String(cellValue).trim() === '' ? '–' : cellValue;
    }

    function applyFilters() {
      const tbody = $sheetTable.querySelector('tbody');
      if (!tbody) return;

      Array.from(tbody.rows).forEach(tableRow => {
        let showRow = true;
        for (const [colIndex, filterValue] of Object.entries(activeFilters)) {
          if (filterValue && tableRow.cells[colIndex].textContent.trim() !== filterValue) {
            showRow = false;
            break;
          }
        }
        tableRow.style.display = showRow ? '' : 'none';
      });

      updateFilterDisplay();
      updateCharts();
      updateGrandTotalHeader();
    }

    function updateFilterDisplay() {
      const activeFilterKeys = Object.keys(activeFilters);
      if (activeFilterKeys.length === 0) {
        $filtersActive.textContent = 'Nenhum filtro ativo';
        $clearFiltersBtn.style.display = 'none';
      } else {
        const filterParts = activeFilterKeys.map(index => `${headersDisplay[index]}: ${activeFilters[index]}`);
        $filtersActive.textContent = 'Filtros: ' + filterParts.join(' | ');
        $clearFiltersBtn.style.display = 'inline-block';
      }
    }

    function clearFilters() {
      Object.keys(activeFilters).forEach(key => delete activeFilters[key]);
      $tableWrapper.querySelectorAll('thead select').forEach(select => select.value = '');
      applyFilters();
    }

    function hasDataChanged(newData, prevData) {
        if (prevData === null) return true;
        if (typeof newData !== 'object' || typeof prevData !== 'object') {
            return newData !== prevData;
        }
        if (newData && prevData && Array.isArray(newData.labels) && Array.isArray(prevData.labels) && Array.isArray(newData.totals) && Array.isArray(prevData.totals)) {
             return JSON.stringify(newData.labels) !== JSON.stringify(prevData.labels) ||
                    JSON.stringify(newData.totals) !== JSON.stringify(prevData.totals);
        }
        return true;
    }

    function aggregateByDate(dateColumnRegex) {
        const dateColIndex = headersFull.findIndex(h => dateColumnRegex.test(h.toLowerCase()));
        if (dateColIndex === -1) {
            console.warn(`Date column not found for regex: ${dateColumnRegex}`);
            return { labels: [], totals: [] };
        }
        const valueColIndex = headersFull.findIndex(h => /valor|total|preço|custo/i.test(h.toLowerCase()) && !/nf/i.test(h.toLowerCase()));
         if (valueColIndex === -1) {
            console.warn("Value column (valor/total/preço/custo) not found.");
            return { labels: [], totals: [] };
        }

        const aggregationMap = new Map();
        getFilteredRows().forEach(row => {
            const date = parseDateValue(row[dateColIndex]);
            if (!date || isNaN(date.getTime())) return;
            const dateKey = date.toISOString().split('T')[0];

            let value = row[valueColIndex];
            if (value == null) return;
            value = typeof value === 'number' ? value : parseFloat(String(value).replace(/[R$\s.]/g, '').replace(',', '.'));

            if (!isNaN(value)) {
                aggregationMap.set(dateKey, (aggregationMap.get(dateKey) || 0) + value);
            }
        });

        const orderedEntries = [...aggregationMap.entries()].sort((a, b) => a[0].localeCompare(b[0]));

        return {
            labels: orderedEntries.map(([key]) => {
                const date = new Date(key + 'T00:00:00Z');
                return formatDateBR(date);
            }),
            totals: orderedEntries.map(([_, value]) => value)
        };
    }

    function aggregateByMonth(dateColumnRegex) {
        const dateColIndex = headersFull.findIndex(h => dateColumnRegex.test(h.toLowerCase()));
        if (dateColIndex === -1) {
            console.warn(`Date column not found for regex: ${dateColumnRegex}`);
            return { labels: [], totals: [] };
        }
        const valueColIndex = headersFull.findIndex(h => /valor|total|preço|custo/i.test(h.toLowerCase()) && !/nf/i.test(h.toLowerCase()));
         if (valueColIndex === -1) {
            console.warn("Value column (valor/total/preço/custo) not found.");
            return { labels: [], totals: [] };
        }

        const aggregationMap = new Map();
        getFilteredRows().forEach(row => {
            const date = parseDateValue(row[dateColIndex]);
            if (!date || isNaN(date.getTime())) return;
            const monthKey = `${date.getUTCFullYear()}-${padZero(date.getUTCMonth())}`;

            let value = row[valueColIndex];
            if (value == null) return;
            value = typeof value === 'number' ? value : parseFloat(String(value).replace(/[R$\s.]/g, '').replace(',', '.'));

            if (!isNaN(value)) {
                aggregationMap.set(monthKey, (aggregationMap.get(monthKey) || 0) + value);
            }
        });

        const orderedEntries = [...aggregationMap.entries()].sort((a, b) => a[0].localeCompare(b[0]));

        return {
            labels: orderedEntries.map(([key]) => {
                const [year, monthIndex] = key.split('-');
                const date = new Date(Date.UTC(+year, +monthIndex, 1));
                return formatMonthYear(date);
            }),
            totals: orderedEntries.map(([_, value]) => value)
        };
    }

    function calculateTomorrowTotal() {
        const dateColIndex = headersFull.findIndex(h => /venc/i.test(h.toLowerCase()));
        if (dateColIndex === -1) {
            console.warn("Due Date column (venc) not found for tomorrow's total.");
            return { total: 0, tomorrowDateObj: null };
        }
        const valueColIndex = headersFull.findIndex(h => /valor|total|preço|custo/i.test(h.toLowerCase()) && !/nf/i.test(h.toLowerCase()));
         if (valueColIndex === -1) {
            console.warn("Value column (valor/total/preço/custo) not found for tomorrow's total.");
            return { total: 0, tomorrowDateObj: null };
        }

        const today = new Date();
        const tomorrow = new Date();
        tomorrow.setUTCDate(today.getUTCDate() + 1);
        tomorrow.setUTCHours(0, 0, 0, 0);

        let total = 0;
        getFilteredRows().forEach(row => {
            const dueDate = parseDateValue(row[dateColIndex]);
            if (dueDate && !isNaN(dueDate.getTime()) &&
                dueDate.getUTCFullYear() === tomorrow.getUTCFullYear() &&
                dueDate.getUTCMonth() === tomorrow.getUTCMonth() &&
                dueDate.getUTCDate() === tomorrow.getUTCDate())
            {
                let value = row[valueColIndex];
                if (value != null) {
                    value = typeof value === 'number' ? value : parseFloat(String(value).replace(/[R$\s.]/g, '').replace(',', '.'));
                    if (!isNaN(value)) {
                        total += value;
                    }
                }
            }
        });
        return { total: total, tomorrowDateObj: tomorrow };
    }

    function getFilteredRows() {
        if (Object.keys(activeFilters).length === 0) {
            return sheetRows;
        }
        return sheetRows.filter(row => {
            for (const [colIndex, filterValue] of Object.entries(activeFilters)) {
                const cellFormattedValue = formatCellValue(row[colIndex], headersDisplay[colIndex]);
                if (filterValue && cellFormattedValue.trim() !== filterValue) {
                    return false;
                }
            }
            return true;
        });
    }

    const baseChartOptions = {
      chart: {
        foreColor: '#cbd5e1',
        toolbar: { show: true, tools: { download: true, selection: false, zoom: false, zoomin: false, zoomout: false, pan: false, reset: true } },
        zoom: { enabled: false },
        animations: { enabled: true, easing: 'easeinout', speed: 500, animateGradually: { enabled: true, delay: 150 }, dynamicAnimation: { enabled: true, speed: 350 } }
      },
      tooltip: { theme: 'dark', y: { formatter: formatTooltip } },
      dataLabels: { enabled: false },
      grid: { borderColor: '#475569', strokeDashArray: 4 },
      legend: { show: false },
      markers: { size: 4, hover: { size: 6 } }
    };

    function buildCharts() {
        renderOverviewChart();
        renderPaymentChart();
        renderMonthlyChart();
        renderTomorrowTotalCard();
        prevOverviewData = aggregateByDate(/venc/i);
        prevPaymentData  = aggregateByDate(/pag/i);
        prevMonthlyData  = aggregateByMonth(/venc/i);
        prevTomorrowTotal = calculateTomorrowTotal().total;
    }

    function updateCharts() {
        renderOverviewChart(true);
        renderPaymentChart(true);
        renderMonthlyChart(true);
        renderTomorrowTotalCard(true);
    }

    function renderTomorrowTotalCard(isUpdate = false) {
        const { total: newTotal, tomorrowDateObj } = calculateTomorrowTotal();
        if (isUpdate && !hasDataChanged(newTotal, prevTomorrowTotal)) return;

        $tomorrowTotalValue.textContent = formatCurrency(newTotal);
        $tomorrowDate.textContent = tomorrowDateObj ? `(${formatDateBR(tomorrowDateObj)})` : '';
        prevTomorrowTotal = newTotal;
    }

    function renderOverviewChart(isUpdate = false) {
        const newData = aggregateByDate(/venc/i);
        if (isUpdate && !hasDataChanged(newData, prevOverviewData)) return;

        const options = {
            series: [{ name: 'Total Venc.', data: newData.totals }],
            xaxis: { categories: newData.labels, labels: { rotate: -45, rotateAlways: false, hideOverlappingLabels: true, style: { fontSize: '10px' } }, tooltip: { enabled: false } },
            yaxis: { labels: { formatter: formatCompact } },
            colors: [CHART_COLORS[0]],
            stroke: { curve: 'smooth', width: 2 },
            fill: { type: 'gradient', gradient: { shadeIntensity: 1, opacityFrom: .5, opacityTo: .1, stops: [0, 90, 100] } }
        };

        if (isUpdate && chartOverview) {
            chartOverview.updateOptions(options, false, true);
        } else {
            chartOverview?.destroy();
            chartOverview = new ApexCharts(document.querySelector('#chart-overview'), {
                ...baseChartOptions, chart: { ...baseChartOptions.chart, type: 'area', height: 280 }, ...options
            });
            chartOverview.render();
        }
        prevOverviewData = newData;
    }

    function renderPaymentChart(isUpdate = false) {
        const newData = aggregateByDate(/pag/i);
        if (isUpdate && !hasDataChanged(newData, prevPaymentData)) return;

        const options = {
            series: [{ name: 'Total Pago', data: newData.totals }],
            xaxis: { categories: newData.labels, labels: { rotate: -45, rotateAlways: false, hideOverlappingLabels: true, style: { fontSize: '10px' } }, tooltip: { enabled: false } },
            yaxis: { labels: { formatter: formatCompact } },
            colors: [CHART_COLORS[1]],
            stroke: { curve: 'smooth', width: 2 },
            fill: { type: 'gradient', gradient: { shadeIntensity: 1, opacityFrom: .5, opacityTo: .1, stops: [0, 90, 100] } }
        };

        if (isUpdate && chartPayment) {
            chartPayment.updateOptions(options, false, true);
        } else {
            chartPayment?.destroy();
            chartPayment = new ApexCharts(document.querySelector('#chart-payment'), {
                ...baseChartOptions, chart: { ...baseChartOptions.chart, type: 'area', height: 280 }, ...options
            });
            chartPayment.render();
        }
        prevPaymentData = newData;
    }

    function renderMonthlyChart(isUpdate = false) {
        const newData = aggregateByMonth(/venc/i);
        if (isUpdate && !hasDataChanged(newData, prevMonthlyData)) return;

        const grandTotal = newData.totals.reduce((sum, total) => sum + total, 0);

        const options = {
            series: newData.totals, labels: newData.labels,
            colors: CHART_COLORS.slice(0, newData.labels.length),
            legend: { ...baseChartOptions.legend, show: true, position: 'bottom', fontSize: '11px', horizontalAlign: 'center', itemMargin: { horizontal: 5, vertical: 3 } },
            plotOptions: {
                pie: {
                    donut: {
                        size: '65%',
                        labels: {
                            show: true,
                            total: { show: true, label: 'Total Geral', fontSize: '14px', fontWeight: 600, color: '#cbd5e1', formatter: () => formatCurrency(grandTotal) },
                            value: { fontSize: '16px', fontWeight: 500, color: '#cbd5e1', formatter: (val) => formatCurrency(parseFloat(val)) }
                        }
                    }
                }
            },
            responsive: [{ breakpoint: 480, options: { chart: { height: 320 }, legend: { position: 'bottom', fontSize: '10px' } } }]
        };

        if (isUpdate && chartMonthly) {
            chartMonthly.updateOptions(options, true, true);
        } else {
            chartMonthly?.destroy();
            chartMonthly = new ApexCharts(document.querySelector('#chart-monthly'), {
                ...baseChartOptions, chart: { ...baseChartOptions.chart, type: 'donut', height: 280 }, ...options
            });
            chartMonthly.render();
        }
        prevMonthlyData = newData;
    }

    function updateGrandTotalHeader() {
        const { totals } = aggregateByMonth(/venc/i);
        const grandTotal = totals.reduce((sum, monthTotal) => sum + monthTotal, 0);
        const filterSuffix = Object.keys(activeFilters).length > 0 ? ' (Filtrado)' : '';
        $monthTotal.textContent = `Total Geral (Venc.)${filterSuffix}: ${formatCurrency(grandTotal)}`;
    }

    function buildInitialUI() {
        buildTable();
        buildCharts();
    }

    function updateUI() {
        buildTable();
        applyFilters();
        renderTomorrowTotalCard(true);
    }

    loadData();
    setInterval(loadData, REFRESH_INTERVAL); // Agora usa o intervalo de 10 minutos

  </script>
</body>
</html>
